#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = []
# ///

from __future__ import annotations

import os
import random
import shlex
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional

# Configuration constants
WORKTREE_BASE = Path.home() / "git" / "worktrees"
ZELLIJ_SESSION = "claude"
BRANCH_PREFIX = "jshepherd"
MAX_COLLISION_ATTEMPTS = 10


def check_prerequisites() -> None:
    """Check that required commands are available."""
    for cmd in ["git", "zellij"]:
        result = subprocess.run(
            ["which", cmd], capture_output=True, text=True
        )
        if result.returncode != 0:
            print(f"Error: '{cmd}' command not found in PATH", file=sys.stderr)
            sys.exit(1)


def check_git_repository() -> bool:
    """Check if current directory is within a git repository."""
    result = subprocess.run(
        ["git", "rev-parse", "--git-dir"],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    return result.returncode == 0


def sanitize_name(name: str) -> str:
    """Sanitize name by replacing spaces with hyphens."""
    return name.replace(" ", "-")


def generate_random_digits() -> str:
    """Generate 6 random digits."""
    return f"{random.randint(0, 999999):06d}"


def branch_exists(branch_name: str) -> bool:
    """Check if a local branch exists."""
    result = subprocess.run(
        ["git", "show-ref", "--verify", "--quiet", f"refs/heads/{branch_name}"],
        capture_output=True,
    )
    return result.returncode == 0


def get_worktree_path(branch_name: str) -> Optional[Path]:
    """Get the worktree path for a branch if it exists."""
    result = subprocess.run(
        ["git", "worktree", "list", "--porcelain"],
        capture_output=True,
        text=True,
        check=True,
    )

    # Parse porcelain output
    # Format: worktree <path>\nHEAD <sha>\nbranch <ref>\n\n
    worktrees = result.stdout.strip().split("\n\n")

    for worktree_block in worktrees:
        lines = worktree_block.strip().split("\n")
        wt_path = None
        wt_branch = None

        for line in lines:
            if line.startswith("worktree "):
                wt_path = line[9:]  # Skip "worktree "
            elif line.startswith("branch "):
                wt_branch = line[7:]  # Skip "branch "

        if wt_branch == f"refs/heads/{branch_name}" and wt_path:
            return Path(wt_path)

    return None


def create_worktree(branch_name: str, path: Path, new_branch: bool) -> None:
    """Create a git worktree."""
    # Ensure parent directory exists
    path.parent.mkdir(parents=True, exist_ok=True)

    try:
        if new_branch:
            # Create new branch and worktree
            print(f"Creating new worktree at {path}...")
            subprocess.run(
                ["git", "worktree", "add", "-b", branch_name, str(path)],
                check=True,
                text=True,
            )
            print(f"Created new worktree: {path}")
        else:
            # Create worktree from existing branch
            print(f"Creating worktree from existing branch at {path}...")
            subprocess.run(
                ["git", "worktree", "add", str(path), branch_name],
                check=True,
                text=True,
            )
            print(f"Created worktree from existing branch: {path}")
    except subprocess.CalledProcessError as e:
        # Check if worktree was actually created despite the error
        # (this can happen when post-checkout hooks fail)
        if path.exists() and (path / ".git").exists():
            print(
                f"Warning: git worktree command failed, but worktree was created successfully at {path}",
                file=sys.stderr,
            )
            if e.stderr:
                print(f"Error message: {e.stderr.strip()}", file=sys.stderr)
            # Continue execution - the worktree is usable
        else:
            error_msg = e.stderr.strip() if e.stderr else str(e)
            print(f"Error creating worktree: {error_msg}", file=sys.stderr)
            sys.exit(1)


def session_exists(session_name: str) -> bool:
    """Check if a Zellij session exists and is active (not exited)."""
    result = subprocess.run(
        ["zellij", "list-sessions"],
        capture_output=True,
        text=True,
    )

    # Check if session exists AND is not in EXITED state
    if session_name not in result.stdout:
        return False

    # Check if the session line contains "EXITED"
    for line in result.stdout.splitlines():
        if session_name in line and "EXITED" in line:
            # Session exists but is exited - delete it so we can create a fresh one
            subprocess.run(
                ["zellij", "delete-session", session_name],
                capture_output=True,
                text=True,
            )
            return False

    return True


def ensure_zellij_session() -> bool:
    """Check if Zellij session exists.
    Returns True if this is a new session (session doesn't exist yet)."""
    return not session_exists(ZELLIJ_SESSION)


def create_tab_and_run_claude(tab_name: str, worktree_path: Path, is_new_session: bool) -> None:
    """Create a new tab and run claude in it."""
    import tempfile

    try:
        # Create a temporary layout file that runs claude
        # For new sessions: include full layout with tab-bar and status-bar
        # For existing sessions: just the pane (inherits session's default template)
        if is_new_session:
            layout_content = f'''layout {{
    default_tab_template {{
        pane size=1 borderless=true {{
            plugin location="tab-bar"
        }}
        children
        pane size=2 borderless=true {{
            plugin location="status-bar"
        }}
    }}
    tab name="{tab_name}" {{
        pane command="claude"
    }}
}}
'''
        else:
            layout_content = f'''layout {{
    tab name="{tab_name}" {{
        pane size=1 borderless=true {{
            plugin location="tab-bar"
        }}
        pane command="claude"
        pane size=2 borderless=true {{
            plugin location="status-bar"
        }}
    }}
}}
'''
        with tempfile.NamedTemporaryFile(mode='w', suffix='.kdl', delete=False) as f:
            f.write(layout_content)
            layout_file = f.name

        try:
            print(f"Creating tab '{tab_name}' and starting claude in {worktree_path}")

            if is_new_session:
                # For new sessions: create session with layout directly (no empty default tab)
                # Run from worktree directory so it inherits the cwd
                subprocess.run(
                    [
                        "zellij",
                        "-l",
                        layout_file,
                        "attach",
                        "-c",
                        "-b",
                        ZELLIJ_SESSION,
                    ],
                    check=True,
                    capture_output=True,
                    text=True,
                    timeout=10,
                    cwd=str(worktree_path),
                )
            else:
                # For existing sessions: add a new tab with layout
                subprocess.run(
                    [
                        "zellij",
                        "-s",
                        ZELLIJ_SESSION,
                        "action",
                        "new-tab",
                        "--name",
                        tab_name,
                        "--layout",
                        layout_file,
                        "--cwd",
                        str(worktree_path),
                    ],
                    check=True,
                    capture_output=True,
                    text=True,
                    timeout=10,
                )

            print(f"Created tab '{tab_name}' and started claude in {worktree_path}")
        finally:
            # Clean up temp file
            Path(layout_file).unlink(missing_ok=True)
    except subprocess.CalledProcessError as e:
        print(f"Error creating tab: {e.stderr}", file=sys.stderr)
        sys.exit(1)
    except subprocess.TimeoutExpired:
        print("Error: Timed out creating tab", file=sys.stderr)
        sys.exit(1)




def attach_to_zellij() -> None:
    """Attach to the Zellij session (replaces current process)."""
    # Give zellij time to process commands and start claude before attaching
    # This ensures the CWD is set and claude is running when we attach
    time.sleep(1.5)
    os.execvp("zellij", ["zellij", "attach", ZELLIJ_SESSION])


def print_help() -> None:
    """Print help message."""
    help_text = """
claude-worktree - Create git worktrees and manage them in Zellij tabs

USAGE:
    claude-worktree <name>

DESCRIPTION:
    Creates a new git worktree with a branch named '{prefix}/<name>-<random>'
    in ~/git/worktrees, then opens it in a new Zellij tab running Claude.

    If a branch/worktree with the same name exists, it will be reused.

ARGUMENTS:
    <name>    Name for the worktree (spaces will be replaced with hyphens)

EXAMPLES:
    claude-worktree "fix login bug"
    claude-worktree feature-123

NOTES:
    - Creates worktrees in: ~/git/worktrees
    - Branch prefix: {prefix}
    - Zellij session: {session}
""".format(prefix=BRANCH_PREFIX, session=ZELLIJ_SESSION)
    print(help_text)


def main() -> int:
    """Main function."""
    # Check arguments
    if len(sys.argv) != 2:
        print_help()
        return 1

    name = sys.argv[1]

    # Check prerequisites
    check_prerequisites()

    if not check_git_repository():
        print("Error: Must be run from within a git repository", file=sys.stderr)
        return 1

    # Sanitize name
    sanitized_name = sanitize_name(name)

    # Try to generate unique branch name (with collision retry)
    branch_name = None
    worktree_path = None

    for attempt in range(MAX_COLLISION_ATTEMPTS):
        digits = generate_random_digits()
        candidate_branch = f"{BRANCH_PREFIX}/{sanitized_name}-{digits}"
        candidate_path = WORKTREE_BASE / f"{sanitized_name}-{digits}"
        tab_name = f"{sanitized_name}-{digits}"

        # Check if branch exists
        if branch_exists(candidate_branch):
            # Branch exists - check if worktree exists
            existing_worktree = get_worktree_path(candidate_branch)

            if existing_worktree:
                # Reuse existing worktree
                print(f"Reusing existing worktree: {existing_worktree}")
                worktree_path = existing_worktree
                branch_name = candidate_branch
                break
            else:
                # Branch exists but no worktree - create worktree from existing branch
                create_worktree(candidate_branch, candidate_path, new_branch=False)
                worktree_path = candidate_path
                branch_name = candidate_branch
                break
        else:
            # Branch doesn't exist - create new branch and worktree
            create_worktree(candidate_branch, candidate_path, new_branch=True)
            worktree_path = candidate_path
            branch_name = candidate_branch
            break

    if branch_name is None or worktree_path is None:
        print(
            f"Error: Failed to create unique branch after {MAX_COLLISION_ATTEMPTS} attempts",
            file=sys.stderr,
        )
        return 1

    # Ensure Zellij session exists and check if it's new
    is_new_session = ensure_zellij_session()

    # Always create a new tab (and delete the default first tab if new session)
    create_tab_and_run_claude(tab_name, worktree_path, is_new_session)

    # Attach to session (replaces current process)
    attach_to_zellij()

    # This line is never reached due to execvp
    return 0


if __name__ == "__main__":
    sys.exit(main())
